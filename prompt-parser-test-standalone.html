<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PromptParser Test - Orbrya Module 4</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0f1629;
            color: #e4e4e7;
            padding: 40px;
            margin: 0;
        }
        h1 { color: #667eea; margin-bottom: 10px; }
        .subtitle { color: #888; margin-bottom: 30px; }
        .test-input { display: flex; gap: 10px; margin-bottom: 30px; }
        input {
            flex: 1; padding: 15px; font-size: 16px;
            background: #1a2744; border: 2px solid #2d3748;
            border-radius: 8px; color: #e4e4e7;
        }
        input:focus { outline: none; border-color: #667eea; }
        button {
            padding: 15px 30px; font-size: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; border: none; border-radius: 8px;
            cursor: pointer; font-weight: bold;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); }
        .results { background: #1a2744; border-radius: 12px; padding: 25px; margin-bottom: 30px; }
        .results h3 { margin-top: 0; color: #667eea; }
        .param-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0; }
        .param-card { background: #0f1629; padding: 15px; border-radius: 8px; text-align: center; }
        .param-value { font-size: 24px; font-weight: bold; color: #00ff88; }
        .param-label { font-size: 12px; color: #888; text-transform: uppercase; }
        .specificity-bar { height: 20px; background: #2d3748; border-radius: 10px; overflow: hidden; margin: 10px 0; }
        .specificity-fill { height: 100%; background: linear-gradient(90deg, #ff4757 0%, #ffc107 50%, #00ff88 100%); transition: width 0.3s; }
        .feedback { padding: 15px; background: rgba(102, 126, 234, 0.1); border-left: 4px solid #667eea; border-radius: 0 8px 8px 0; margin: 15px 0; }
        .suggestions { margin-top: 10px; font-size: 14px; color: #ffc107; }
        .examples { margin-top: 30px; }
        .examples h3 { color: #667eea; }
        .example-btn { display: inline-block; padding: 10px 15px; margin: 5px; background: #2d3748; border: none; border-radius: 6px; color: #e4e4e7; cursor: pointer; font-size: 13px; }
        .example-btn:hover { background: #3d4f68; }
        .test-suite { margin-top: 40px; padding-top: 30px; border-top: 1px solid #2d3748; }
        .test-result { padding: 8px 15px; margin: 5px 0; border-radius: 6px; font-family: monospace; font-size: 13px; }
        .test-pass { background: rgba(0, 255, 136, 0.1); border-left: 3px solid #00ff88; }
        .test-fail { background: rgba(255, 71, 87, 0.1); border-left: 3px solid #ff4757; }
        .summary { font-size: 18px; font-weight: bold; margin-top: 20px; padding: 15px; background: #1a2744; border-radius: 8px; }
    </style>
</head>
<body>
    <h1>üß™ PromptParser Test</h1>
    <p class="subtitle">Module 4: Natural Language Prompt Parsing (Standalone)</p>
    
    <div class="test-input">
        <input type="text" id="prompt-input" placeholder="Try: 'Create 50 pine trees in a grid'" />
        <button onclick="testPrompt()">Parse</button>
    </div>
    
    <div class="results" id="results">
        <h3>üìä Parse Results</h3>
        <p style="color: #888;">Enter a prompt above to see parsing results...</p>
    </div>
    
    <div class="examples">
        <h3>üí° Example Prompts (click to test)</h3>
        <div id="example-buttons"></div>
    </div>
    
    <div class="test-suite">
        <h3>üî¨ Run Full Test Suite</h3>
        <button onclick="runTests()">Run All Tests</button>
        <div id="test-results"></div>
    </div>

    <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INLINED PromptParser.js (for standalone testing without server)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    class PromptParser {
        constructor() {
            this.treeTypes = {
                pine: ['pine', 'conifer', 'evergreen', 'fir', 'spruce'],
                oak: ['oak', 'deciduous', 'leafy'],
                birch: ['birch', 'white tree', 'silver'],
                palm: ['palm', 'tropical', 'beach'],
                generic: ['tree', 'trees', 'forest']
            };
            
            this.arrangements = {
                random: ['random', 'scattered', 'natural', 'organic', 'wild'],
                grid: ['grid', 'rows', 'columns', 'organized', 'lined up', 'orderly'],
                cluster: ['cluster', 'group', 'clump', 'bunch', 'together'],
                line: ['line', 'row', 'path', 'along', 'border', 'edge'],
                circle: ['circle', 'ring', 'around', 'circular', 'surround']
            };
            
            this.densityKeywords = {
                dense: ['dense', 'thick', 'packed', 'crowded', 'lots of', 'many', 'full'],
                sparse: ['sparse', 'spread out', 'few', 'scattered', 'minimal', 'light'],
                normal: ['normal', 'moderate', 'some', 'several']
            };
            
            this.sizeKeywords = {
                varied: ['varied', 'different', 'diverse', 'mixed', 'various', 'assorted'],
                uniform: ['same', 'uniform', 'identical', 'equal', 'consistent'],
                large: ['large', 'big', 'tall', 'huge', 'giant'],
                small: ['small', 'tiny', 'short', 'little', 'mini']
            };
            
            this.quantifiers = {
                few: { min: 5, max: 15 },
                some: { min: 15, max: 35 },
                several: { min: 20, max: 40 },
                many: { min: 50, max: 100 },
                lots: { min: 75, max: 150 },
                bunch: { min: 30, max: 60 }
            };
            
            this.defaults = {
                treeCount: 25,
                treeType: 'generic',
                arrangement: 'random',
                sizeVariation: false,
                density: 'normal'
            };
        }

        parsePrompt(userPrompt) {
            const normalizedPrompt = this.normalizePrompt(userPrompt);
            
            const params = {
                treeCount: this.extractNumber(normalizedPrompt),
                treeType: this.extractTreeType(normalizedPrompt),
                arrangement: this.extractArrangement(normalizedPrompt),
                sizeVariation: this.extractSizeVariation(normalizedPrompt),
                density: this.extractDensity(normalizedPrompt)
            };
            
            if (params.treeCount === this.defaults.treeCount && params.density !== 'normal') {
                params.treeCount = this.applyDensityModifier(params.treeCount, params.density);
            }
            
            const specificity = this.calculateSpecificity(normalizedPrompt, params);
            const interpretation = this.generateInterpretation(params);
            const feedback = this.generateFeedback(params, normalizedPrompt, specificity);
            
            return { params, specificity, interpretation, feedback, rawPrompt: userPrompt, normalized: normalizedPrompt };
        }

        normalizePrompt(prompt) {
            return prompt.toLowerCase().replace(/[^\w\s]/g, ' ').replace(/\s+/g, ' ').trim();
        }

        extractNumber(prompt) {
            const numberMatch = prompt.match(/(\d+)\s*(?:trees?|objects?)?/i);
            if (numberMatch) return Math.max(1, Math.min(parseInt(numberMatch[1], 10), 500));
            
            const aboutMatch = prompt.match(/(?:about|around|approximately|roughly)\s*(\d+)/i);
            if (aboutMatch) {
                const num = parseInt(aboutMatch[1], 10);
                const variance = Math.floor(num * 0.1);
                return Math.max(1, Math.min(num + Math.floor(Math.random() * variance * 2) - variance, 500));
            }
            
            for (const [word, range] of Object.entries(this.quantifiers)) {
                if (new RegExp(`\\b${word}\\b`, 'i').test(prompt)) {
                    return Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
                }
            }
            
            if (/\bforest\b/i.test(prompt)) return 50;
            if (/\ba tree\b/i.test(prompt) && !/trees/i.test(prompt)) return 1;
            
            return this.defaults.treeCount;
        }

        extractTreeType(prompt) {
            for (const [type, keywords] of Object.entries(this.treeTypes)) {
                if (type === 'generic') continue;
                for (const keyword of keywords) {
                    if (prompt.includes(keyword)) return type;
                }
            }
            if (/mixed|variety|different types|various/i.test(prompt)) return 'mixed';
            return this.defaults.treeType;
        }

        extractArrangement(prompt) {
            for (const [pattern, keywords] of Object.entries(this.arrangements)) {
                for (const keyword of keywords) {
                    const regex = keyword.includes(' ') ? new RegExp(keyword, 'i') : new RegExp(`\\b${keyword}\\b`, 'i');
                    if (regex.test(prompt)) return pattern;
                }
            }
            return this.defaults.arrangement;
        }

        extractSizeVariation(prompt) {
            for (const keyword of this.sizeKeywords.varied) if (prompt.includes(keyword)) return true;
            for (const keyword of this.sizeKeywords.uniform) if (prompt.includes(keyword)) return false;
            return this.defaults.sizeVariation;
        }

        extractDensity(prompt) {
            for (const [level, keywords] of Object.entries(this.densityKeywords)) {
                for (const keyword of keywords) {
                    const regex = keyword.includes(' ') ? new RegExp(keyword, 'i') : new RegExp(`\\b${keyword}\\b`, 'i');
                    if (regex.test(prompt)) return level;
                }
            }
            return this.defaults.density;
        }

        applyDensityModifier(baseCount, density) {
            if (density === 'dense') return Math.floor(baseCount * 2);
            if (density === 'sparse') return Math.floor(baseCount * 0.5);
            return baseCount;
        }

        calculateSpecificity(prompt, params) {
            let score = 0;
            if (/\d+/.test(prompt)) score += 30;
            else if (Object.keys(this.quantifiers).some(q => prompt.includes(q))) score += 15;
            if (params.treeType !== 'generic') score += 20;
            if (params.arrangement !== 'random') score += 20;
            const hasSizeKeyword = [...this.sizeKeywords.varied, ...this.sizeKeywords.uniform, ...this.sizeKeywords.large, ...this.sizeKeywords.small].some(k => prompt.includes(k));
            if (hasSizeKeyword) score += 15;
            if (params.density !== 'normal') score += 15;
            return Math.min(score, 100);
        }

        generateInterpretation(params) {
            const parts = [];
            parts.push(`${params.treeCount} ${params.treeCount === 1 ? 'tree' : 'trees'}`);
            if (params.treeType !== 'generic') parts[0] = `${params.treeCount} ${params.treeType} ${params.treeCount === 1 ? 'tree' : 'trees'}`;
            parts.push(params.arrangement !== 'random' ? `in a ${params.arrangement} pattern` : 'randomly placed');
            if (params.sizeVariation) parts.push('with varied sizes');
            if (params.density === 'dense') parts.push('packed densely');
            else if (params.density === 'sparse') parts.push('spread out');
            return parts.join(', ');
        }

        generateFeedback(params, prompt, specificity) {
            const feedback = { message: '', suggestions: [], quality: 'good' };
            if (specificity >= 70) { feedback.quality = 'excellent'; feedback.message = '‚ú® Great prompt! Very specific and clear.'; }
            else if (specificity >= 40) { feedback.quality = 'good'; feedback.message = 'üëç Good prompt! Here\'s what I understood:'; }
            else { feedback.quality = 'needs_detail'; feedback.message = 'üí° Your prompt could be more specific. I\'ll use defaults for missing details.'; }
            
            if (!/\d+/.test(prompt) && !Object.keys(this.quantifiers).some(q => prompt.includes(q))) feedback.suggestions.push('Try specifying a number (e.g., "50 trees")');
            if (params.treeType === 'generic') feedback.suggestions.push('Specify a tree type (e.g., "pine trees", "oak trees")');
            if (params.arrangement === 'random' && !/random|scatter/i.test(prompt)) feedback.suggestions.push('Describe the arrangement (e.g., "in a grid", "clustered together")');
            return feedback;
        }

        getExamplePrompts() {
            return [
                { text: 'Create a forest with 50 pine trees', description: 'Basic forest' },
                { text: 'Spawn 30 oak trees in a grid pattern', description: 'Organized layout' },
                { text: 'Generate a dense cluster of varied trees', description: 'Using modifiers' },
                { text: 'Place a few birch trees in a circle', description: 'Specific arrangement' },
                { text: 'Create many scattered palm trees', description: 'Quantity words' },
                { text: 'Make a sparse forest with tall pines', description: 'Density + size' }
            ];
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TEST UI CODE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const parser = new PromptParser();
    window.parser = parser;
    
    // Populate example buttons
    const examples = parser.getExamplePrompts();
    const exampleContainer = document.getElementById('example-buttons');
    examples.forEach(ex => {
        const btn = document.createElement('button');
        btn.className = 'example-btn';
        btn.textContent = ex.text;
        btn.title = ex.description;
        btn.onclick = () => {
            document.getElementById('prompt-input').value = ex.text;
            testPrompt();
        };
        exampleContainer.appendChild(btn);
    });
    
    function testPrompt() {
        const input = document.getElementById('prompt-input').value;
        if (!input.trim()) return;
        
        const result = parser.parsePrompt(input);
        displayResults(result);
    }
    
    function displayResults(result) {
        const container = document.getElementById('results');
        const p = result.params;
        const f = result.feedback;
        
        container.innerHTML = `
            <h3>üìä Parse Results</h3>
            <div class="param-grid">
                <div class="param-card"><div class="param-value">${p.treeCount}</div><div class="param-label">Tree Count</div></div>
                <div class="param-card"><div class="param-value">${p.treeType}</div><div class="param-label">Tree Type</div></div>
                <div class="param-card"><div class="param-value">${p.arrangement}</div><div class="param-label">Arrangement</div></div>
                <div class="param-card"><div class="param-value">${p.density}</div><div class="param-label">Density</div></div>
                <div class="param-card"><div class="param-value">${p.sizeVariation ? 'Yes' : 'No'}</div><div class="param-label">Size Variation</div></div>
            </div>
            <h4>üéØ Specificity Score: ${result.specificity}/100</h4>
            <div class="specificity-bar"><div class="specificity-fill" style="width: ${result.specificity}%"></div></div>
            <h4>üìù Interpretation</h4>
            <p>${result.interpretation}</p>
            <div class="feedback">
                <strong>${f.message}</strong>
                ${f.suggestions.length > 0 ? `<div class="suggestions">${f.suggestions.map(s => `<div>üí° ${s}</div>`).join('')}</div>` : ''}
            </div>
        `;
    }
    
    function runTests() {
        const testCases = [
            { prompt: 'Create 50 trees', expected: { treeCount: 50 } },
            { prompt: 'Spawn 30 pine trees', expected: { treeCount: 30, treeType: 'pine' } },
            { prompt: 'Create pine trees', expected: { treeType: 'pine' } },
            { prompt: 'Spawn some birch', expected: { treeType: 'birch' } },
            { prompt: '50 trees in a grid', expected: { arrangement: 'grid' } },
            { prompt: 'Trees clustered together', expected: { arrangement: 'cluster' } },
            { prompt: 'Trees in a circle', expected: { arrangement: 'circle' } },
            { prompt: 'Dense forest', expected: { density: 'dense' } },
            { prompt: 'Sparse trees', expected: { density: 'sparse' } },
            { prompt: 'Trees with varied sizes', expected: { sizeVariation: true } },
            { prompt: 'Same size trees', expected: { sizeVariation: false } },
            { prompt: 'Create a tree', expected: { treeCount: 1 } },
            { prompt: 'forest', expected: { treeCount: 50 } },
            { prompt: '1000 trees', expected: { treeCount: 500 } },
            { prompt: 'Create 75 pine trees in a cluster with varied sizes', expected: { treeCount: 75, treeType: 'pine', arrangement: 'cluster', sizeVariation: true } },
        ];
        
        let passed = 0, failed = 0;
        const results = [];
        
        testCases.forEach((test, i) => {
            const result = parser.parsePrompt(test.prompt);
            let testPassed = true;
            const failures = [];
            
            for (const [key, expected] of Object.entries(test.expected)) {
                const actual = result.params[key];
                if (Array.isArray(expected)) {
                    if (actual < expected[0] || actual > expected[1]) { testPassed = false; failures.push(`${key}: expected ${expected[0]}-${expected[1]}, got ${actual}`); }
                } else if (actual !== expected) { testPassed = false; failures.push(`${key}: expected ${expected}, got ${actual}`); }
            }
            
            if (testPassed) passed++; else failed++;
            results.push({ prompt: test.prompt, passed: testPassed, failures });
        });
        
        const container = document.getElementById('test-results');
        let html = results.map((r, i) => `<div class="test-result ${r.passed ? 'test-pass' : 'test-fail'}">${r.passed ? '‚úÖ' : '‚ùå'} "${r.prompt.substring(0, 50)}${r.prompt.length > 50 ? '...' : ''}"${r.failures.length > 0 ? `<br><small style="color:#ff4757">${r.failures.join(', ')}</small>` : ''}</div>`).join('');
        
        const pct = Math.round(passed / testCases.length * 100);
        const color = pct >= 80 ? '#00ff88' : pct >= 60 ? '#ffc107' : '#ff4757';
        html += `<div class="summary" style="color: ${color}">Results: ${passed}/${testCases.length} passed (${pct}%)</div>`;
        
        container.innerHTML = html;
    }
    
    document.getElementById('prompt-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') testPrompt(); });
    console.log('[PromptParser Test] Ready! Access parser via window.parser');
    </script>
</body>
</html>
